<!DOCTYPE html>
<html lang="en" ng-app="myApp">
<head>
    <meta charset="UTF-8">
    <title></title>
    <script type="text/javascript" src="angular.min.js"></script>
    <script>
        angular.module('myApp',[])
                .directive('myDirective',function(){
                    return {
                        restrict:'A',
                        scope:true
                    }
                })
                .controller('SomeController',['$scope',function($scope){
                }])
                .controller('SecondController',['$scope',function($scope){
                }])
                .directive('myScope',function(){
                    return{
                        restrict:'A',
                        replace:true,
                        scope:true,
                        //当把scope属性设置为true时，这表明我们创建的指令要创建一个新的作用域，这个作用域继承自我们的父作用域
                        //我们新创建的作用域是一个新的作用域，只不过在初始化的时候，用了父作用域的属性和方法去填充我们这个新的作用域。它和父作用域不是同一个作用域
                        //当我们将scope设置为false的时候,我们创建的指令和父作用域（其实是同一个作用域）共享同一个model模型，所以在指令中修改模型数据，它会反映到父作用域的模型中
                        //scope默认值为false
                        template:
                        '<div class="my-scope">'+
                                '<h3>下面部分是指令生成的</h3>'+
                                '我的名字是：<span ng-bind="name"></span><br/>'+
                                '我的年龄是：<span ng-bind="age"></span><br/>'+
                                '<input type="text" ng-model="name"'+
                                "</div>"
                    }
                })
                .controller('myCtrl',['$scope',function($scope){
                    $scope.age=13;
                    $scope.name="Levent";

                }]);
    </script>
</head>
<body>
<div ng-init="someProperty='some data'">
    <div ng-init="siblingProperty='moredata'">
        Inside Div Two:{{ aThirdProperty }}
        <div ng-init="aThirdProperty='data for 3rd property'"
                ng-controller="SomeController">
            Inside Div Three: {{aThirdProperty}}
            <div ng-controller="SecondController">
                Inside Div Four: {{aThirdProperty}}
                <br/>
                Outside myDirective: {{ myProperty }}
                <div my-directive ng-init="myProperty='Wow, this is cool'">
                    Inside mydirective: {{myProperty}}
                </div>
            </div>
        </div>
    </div>
</div>
<br/>
<h4>当把scope属性设置为true时，这表明我们创建的指令要创建一个新的作用域，这个作用域继承自我们的父作用域</h4>
<h4>我们新创建的作用域是一个新的作用域，只不过在初始化的时候，用了父作用域的属性和方法去填充我们这个新的作用域。它和父作用域不是同一个作用域</h4>
<h4>当我们将scope设置为false的时候,我们创建的指令和父作用域（其实是同一个作用域）共享同一个model模型，所以在指令中修改模型数据，它会反映到父作用域的模型中</h4>
<h4>scope默认值为false</h4>
<div ng-controller="myCtrl">
    <div>我的名字是：<span ng-bind="name"></span>
        <br/>
    我的年龄是：<span ng-bind="age"></span></div>
    <div my-scope></div>
</div>
<br/>
<testarea>
    scope:false修改为scope:true
    然后我们再试着在我们的input输入框中写一些字符串，会发现，指令中的那个name发生了变化，但是指令外的那个name却没有发生变化，这说明了一个问题。
    当我们将scope设置为true的时候，我们就新创建了一个作用域，只不过这个作用域是继承了我们的父作用域；我觉得可以这样理解，我们新创建的作用域是一个新的作用域，只不过在初始化的时候，用了父作用域的属性和方法去填充我们这个新的作用域。它和父作用域不是同一个作用域。
    当我们将scope设置为false的时候,我们创建的指令和父作用域（其实是同一个作用域）共享同一个model模型，所以在指令中修改模型数据，它会反映到父作用域的模型中。
    Online Code Part2
</testarea>
</body>
</html>