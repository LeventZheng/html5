<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>无标题文档</title>
</head>
<script type="text/javascript">
	function baseClass()
	{
    	this.showMsg = function()
    	{
        	alert("baseClass::showMsg");   
    	}
	}

	function extendClass()
	{
    	this.showMsg =function ()
    	{
       		 alert("extendClass::showMsg");
    	}
	}

	extendClass.prototype = new baseClass();
	var instance = new extendClass();

	instance.showMsg();//显示extendClass::showMsg

	//函数运行时会先去本体的函数中去找，如果找到则运行，找不到则去prototype中寻找函数。或者可以理解为prototype不会克隆同名函数
	
	//如果我想使用extendClass的一个实例instance调用baseClass的对象方法showMsg怎么办？
	//答案是可以使用call:
	var baseinstance = new baseClass();
	baseinstance.showMsg.call(instance);//显示baseClass::showMsg	
	//这里的baseinstance.showMsg.call(instance);阅读为"将instance当做baseinstance来调用，调用它的对象方法showMsg
</script>
<body>
</body>
</html>
